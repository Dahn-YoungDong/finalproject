---
title: "structure"
author: "Dahn-Young Dong"
date: "11/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

_filtered_neutral.vcf is the input file, saved from the output from markdown "filter"

#------------------------------------------------------------------------------
#                       3. Genetic Structure using TESS3 
#------------------------------------------------------------------------------
# Following this tutorial: https://bcm-uga.github.io/TESS3_encho_sen/articles/main-vignette.html


```{r}
library(ggplot2)
library(raster)
library(maps)
```

###3.1. INPUT FILES FOR TESS:
```{r}
#A. Load the .VCF file with only neutral SNPs:
snps = vcfLink(paste0("vcf/", project_name,"_filtered_neutral.vcf"), overwriteID=T)
VCFsummary(snps) ##277 individuals and 5268 SNPs.
```

```{r}
#B. Create a Genotype matrix
genotypes = GenotypeMatrix(snps) # only returns biallelic
genotypes[1:10, 1:10] ## -1 is missing;
class(genotypes)
genotypes = replace(genotypes, genotypes == -1, NA)
```

```{r}
#C. Create a Matrix with long and lat 
coordinates = snps@meta[,4:5]
class(coordinates)
coordinates = data.matrix(coordinates, rownames.force = NA)
class(coordinates)
#verify the coords
plot(coordinates, pch = 19, cex = .5, xlab = "Longitude", ylab = "Latitude")
```

###3.2. RUNNING THE TESS3R FUNCTION:
#A. Costumize values for the run
lambda_values = c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5) #test lambda values around 1.
K = c(1:10) # set the number of K to be tested
replications = 5 # number of replication in each K
ploidy = 2 # species ploidy
CPU = 4 #Number of cores for run in parallel
mask = 0.05 #porportion of masked values

#B.Run a loop for all alpha values
set.seed(13)
for (i in lambda_values){
  tess3.ls = tess3(genotypes, coord = coordinates, K = K, mask = mask, lambda = i,
                   method = "projected.ls", max.iteration = 5000, rep = replications,
                   ploidy = ploidy, openMP.core.num = CPU)
  save(tess3.ls, file = paste0("./Results_TESS/Tess3ls_Lambda_", i,"_", project_name, ".RData"))
  
}

#C. Choose the lambda with the minimum cross-validation value:
#create a matrix to save results
cross_value = matrix(NA, max(K)*length(lambda_values), 3)
colnames(cross_value) = c("K", "Lambda", "Crossvalidation")

loop = 0 #Always set loop = 0.
for (i in lambda_values){
  load(file = paste0("./Results_TESS/Tess3ls_Lambda_", i,"_", project_name, ".RData"))
  for (j in 1:max(K)){
    loop=loop+1
    res = Gettess3res(tess3.ls, K=j)
    cross_value[loop,1] = j
    cross_value[loop,2] = i
    cross_value[loop,3] = min(res$crossvalid.crossentropy)}
}
#save as csv
write.csv(cross_value,paste0("./Results_TESS/Tess3ls_Crossvalidation_values_", project_name, ".csv"))
#choose best lambda
lambda_tess = as.vector(cross_value[cross_value[,3] == min(cross_value[,3]), ][2])
lambda_tess

#D. Choose best K:
#load the best lambda project:
load(file = paste0("./Results_TESS/Tess3ls_Lambda_", lambda_tess,"_", project_name, ".RData"))
#plot results
pdf(paste0("./Results_TESS/TESS3_PlotK_CrossValidation_Lambda_", lambda_tess, ".pdf"), onefile =F)
plot.new()
plot(tess3.ls, pch = 19, col = "blue", type="b",lwd=2,
     crossvalid = T, crossentropy = T,
     xlab = "Number of ancestral populations", cex.lab=1.5,
     ylab = "Cross-validation score")
dev.off()

#E.Choose the Best K and create the Q-matrix
#Best K
optimal_K = 5
res_tess3 = Gettess3res(tess3.ls, K=optimal_K)

#F. Structure-like barplot for the Q-matrix
my.colors = c('red', 'pink', "darkslategrey", 'blue', 'yellow') #choose the colors according to the number of K
my.palette = CreatePalette(my.colors, 9)
pdf("./Results_TESS/TESS_Ancestry.pdf", onefile =F)
plot.new()
barplot(res_tess3$Q, border = NA, space = 0,
        xlab = "Individuals", ylab = "Ancestry proportions",
        main = "Ancestry matrix", col.palette = my.palette) -> bp
axis(1, at = 1:nrow(res_tess3$Q), labels = bp$order, las = 3, cex.axis = .4)
dev.off()

#G. Spatial interpolation of ancestry coefficient
pdf("./Results_TESS/TESS_MAP.pdf", onefile =F)
plot.new()
plot(res_tess3$Q, coordinates, method = "map.max", interpol = FieldsKrigModel(10),
     main = "Ancestry coefficients",cex.main=1.5,
     xlab = "Longitude", ylab = "Latitude",cex.lab=1.3,
     resolution = c(700,700), cex = 1.5,
     col.palette = my.palette)
dev.off()

#H. Add admixture coefficient and replace the population ID to vcf file
Qmat_tess = as.data.frame(res_tess3$Q)
head(Qmat_tess)

columns = c() 

for (i in 1:ncol(Qmat_tess)){
  columns[i] = paste0("Adx_Coeff_TESS_", i)
}

colnames(Qmat_tess) = columns
head(Qmat_tess)
head(snps_fil_ldF_neutral@meta)
tail(snps_fil_ldF_neutral@meta)

for (i in 1:optimal_K){
  j = ncol(snps_fil_ldF_neutral@meta)+1
  snps_fil_ldF_neutral@meta[,j] = Qmat_tess[i]
}
head(snps_fil_ldF_neutral@meta)
tail(snps_fil_ldF_neutral@meta)

#verify individuals and maximum Adx_Coeff and add to metafile:
popIds = apply(Qmat_tess, 1, which.max)
snps_fil_ldF_neutral@meta$PopID_tess <- popIds
head(snps_fil_ldF_neutral@meta)
tail(snps_fil_ldF_neutral@meta)

#I. Save new vcf file with TESS results and pop ID
Save(snps_fil_ldF_neutral, paste0("vcf/", project_name, "_filtered_neutral_LEA_DAPC_TESS.vcf")) #save vcf
write.csv(snps_fil_ldF_neutral@meta, paste0("Results_Metafiles/ancestry_coef_LEA_DAPC_TESS_", project_name, ".csv"), quote = F) #save result as table
write.csv(as.data.frame(snps_fil_ldF_neutral@meta$PopID_snmf), file= paste0("Results_Metafiles/", project_name, "_neutral_popsID_LEA_DAPC_TESS.csv")) #save only pop ID from sNMF

VCFsummary(snps_fil_ldF_neutral) #277 individuals and 5268 SNPs.
